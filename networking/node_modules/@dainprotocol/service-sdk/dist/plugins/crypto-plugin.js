"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CryptoPlugin = void 0;
const base_1 = require("./base");
const cuid2_1 = require("@paralleldrive/cuid2");
/**
 * CryptoPlugin for handling cryptocurrency transaction workflows
 *
 * This plugin allows services to request transaction signatures from clients
 * by sending back unsigned transactions. Clients can provide their wallet
 * addresses which tools can access and use to create appropriate transactions.
 */
class CryptoPlugin extends base_1.BaseDainPlugin {
    id = 'crypto-plugin';
    name = 'Crypto Plugin';
    version = '1.0.0';
    description = 'Handles cryptocurrency wallet information and transaction signing requests';
    type = 'both';
    config;
    wallets;
    /**
     * Create a new CryptoPlugin instance
     * @param config Plugin configuration or array of wallet information
     *
     * @example
     * // Initialize with wallet information directly
     * const cryptoPlugin = new CryptoPlugin([
     *   { chain: 'eth', address: '0x1234...' },
     *   { chain: 'sol', address: 'Sol456...' }
     * ]);
     *
     * @example
     * // Initialize with full configuration
     * const cryptoPlugin = new CryptoPlugin({
     *   supportedChains: ['eth', 'sol'],
     *   wallets: [
     *     { chain: 'eth', address: '0x1234...' },
     *     { chain: 'sol', address: 'Sol456...' }
     *   ]
     * });
     */
    constructor(configOrWallets = {}) {
        super();
        // Handle the case where an array of wallets is passed directly
        if (Array.isArray(configOrWallets)) {
            this.config = { supportedChains: ['eth', 'sol', 'arb'] };
            this.wallets = [...configOrWallets];
        }
        else {
            // Set default supported chains if not provided
            this.config = {
                supportedChains: configOrWallets.supportedChains || ['eth', 'sol', 'arb'],
                wallets: configOrWallets.wallets
            };
            this.wallets = configOrWallets.wallets || [];
        }
    }
    /**
     * Set or update wallet information
     * @param wallets Array of wallet information
     */
    setWallets(wallets) {
        this.wallets = [...wallets];
        // Update config as well for consistency
        this.config.wallets = [...wallets];
    }
    /**
     * Add a single wallet
     * @param wallet Wallet information to add
     */
    addWallet(wallet) {
        // Remove any existing wallet for the same chain
        this.wallets = this.wallets.filter(w => w.chain !== wallet.chain);
        // Add the new wallet
        this.wallets.push(wallet);
        // Update config as well
        this.config.wallets = [...this.wallets];
    }
    /**
     * Get all configured wallets
     * @returns Array of wallet information
     */
    getWallets() {
        return [...this.wallets];
    }
    /**
     * Get plugin input data from a tool context with proper typing
     */
    getInputData(context) {
        return super.getInputData(context);
    }
    /**
     * Get plugin output data from a response with proper typing
     */
    getResponseData(response) {
        return super.getResponseData(response);
    }
    /**
     * Create a standardized response for this plugin with proper typing
     */
    createResponse(data) {
        return super.createResponse(data);
    }
    /**
     * Get user wallets from context
     * @param context Tool context
     * @returns Array of wallet information or empty array if none found
     */
    getUserWallets(context) {
        const pluginData = this.getInputData(context);
        if (!pluginData || !pluginData.wallets) {
            return [];
        }
        return pluginData.wallets;
    }
    /**
     * Get wallet address for a specific chain
     * @param context Tool context
     * @param chain Blockchain network
     * @returns Wallet address or undefined if not found
     */
    getUserWalletForChain(context, chain) {
        const wallets = this.getUserWallets(context);
        const wallet = wallets.find(w => w.chain === chain);
        return wallet?.address;
    }
    /**
     * Helper to create a transaction signature request
     * @param transactions Array of unsigned transactions
     * @returns Properly formatted transaction signature request
     */
    createTransactionRequest(transactions) {
        // Ensure each transaction has a unique ID
        const txsWithIds = transactions.map(tx => {
            if (!tx.id) {
                return {
                    ...tx,
                    id: (0, cuid2_1.createId)()
                };
            }
            return tx;
        });
        return { txs: txsWithIds };
    }
    /**
     * Create a single transaction with a unique ID
     * @param transaction Transaction data, ID will be generated if not provided
     * @returns Transaction with a guaranteed unique ID
     */
    createTransaction(transaction) {
        return {
            ...transaction,
            id: transaction.id || (0, cuid2_1.createId)()
        };
    }
    /**
     * Get requested transaction signatures from a response
     * @param response Tool response
     * @returns Array of transaction signature requests or empty array if none
     */
    getRequestedCryptoSignatures(response) {
        const pluginData = this.getResponseData(response);
        if (!pluginData || !pluginData.signatureRequests) {
            // Try to extract from data property if not found in plugin data
            if (response.data?.signatureRequests) {
                return response.data.signatureRequests;
            }
            return [];
        }
        return pluginData.signatureRequests;
    }
    /**
     * Get a specific transaction by ID from all signature requests
     * @param response Tool response
     * @param id Transaction ID to find
     * @returns Transaction or undefined if not found
     */
    getTransactionById(response, id) {
        const requests = this.getRequestedCryptoSignatures(response);
        for (const request of requests) {
            const tx = request.txs.find(tx => tx.id === id);
            if (tx)
                return tx;
        }
        return undefined;
    }
    /**
     * Process client input before sending to service
     * Automatically adds wallet information to the request
     */
    async processInputClient(input) {
        // Combine explicitly provided wallets with configured wallets
        const inputWallets = input.wallets || [];
        // Create a map of chains to addresses for quick lookup
        const walletMap = new Map();
        // Add the explicitly provided wallets first
        for (const wallet of inputWallets) {
            walletMap.set(wallet.chain, wallet.address);
        }
        // Add the configured wallets where there isn't already a wallet for that chain
        for (const wallet of this.wallets) {
            if (!walletMap.has(wallet.chain)) {
                walletMap.set(wallet.chain, wallet.address);
            }
        }
        // Convert back to array
        const combinedWallets = Array.from(walletMap.entries()).map(([chain, address]) => ({ chain: chain, address }));
        return {
            wallets: combinedWallets
        };
    }
    /**
     * Process service output before sending to client
     */
    async processOutputService(output) {
        // Extract signature requests from the data property if they exist
        let signatureRequests = [];
        // Check if output has data property with signatureRequests
        if (output?.data?.signatureRequests) {
            signatureRequests = output.data.signatureRequests.map((req) => {
                // Ensure all transactions have IDs
                const txsWithIds = req.txs.map(tx => {
                    if (!tx.id) {
                        return {
                            ...tx,
                            id: (0, cuid2_1.createId)()
                        };
                    }
                    return tx;
                });
                return { txs: txsWithIds };
            });
        }
        // Also check if it's a context response where toolResult contains the data
        if (output?.toolResult?.data?.signatureRequests) {
            signatureRequests = output.toolResult.data.signatureRequests.map((req) => {
                // Ensure all transactions have IDs
                const txsWithIds = req.txs.map(tx => {
                    if (!tx.id) {
                        return {
                            ...tx,
                            id: (0, cuid2_1.createId)()
                        };
                    }
                    return tx;
                });
                return { txs: txsWithIds };
            });
        }
        // Return the extracted signatureRequests
        return {
            signatureRequests: signatureRequests.length > 0 ? signatureRequests : undefined
        };
    }
    /**
     * Process client output after receiving service response
     */
    async processOutputClient(output) {
        // Ensure all transactions in the response have IDs
        if (output?.plugins?.[this.id]?.signatureRequests) {
            output.plugins[this.id].signatureRequests = output.plugins[this.id].signatureRequests.map((req) => {
                // Ensure all transactions have IDs
                const txsWithIds = req.txs.map(tx => {
                    if (!tx.id) {
                        return {
                            ...tx,
                            id: (0, cuid2_1.createId)()
                        };
                    }
                    return tx;
                });
                return { txs: txsWithIds };
            });
        }
        // Also check data object for signatureRequests
        if (output?.data?.signatureRequests) {
            output.data.signatureRequests = output.data.signatureRequests.map((req) => {
                // Ensure all transactions have IDs
                const txsWithIds = req.txs.map(tx => {
                    if (!tx.id) {
                        return {
                            ...tx,
                            id: (0, cuid2_1.createId)()
                        };
                    }
                    return tx;
                });
                return { txs: txsWithIds };
            });
        }
        return output;
    }
    /**
     * Process service input before handling the request
     */
    async processInputService(input) {
        // No modifications needed for service input processing
        return input;
    }
}
exports.CryptoPlugin = CryptoPlugin;
//# sourceMappingURL=crypto-plugin.js.map