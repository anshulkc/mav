"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
//File: src/___tests___/integration.test.ts
const nodeService_1 = require("../service/nodeService");
const core_1 = require("@/service/core");
const zod_1 = require("zod");
const supertest_1 = tslib_1.__importDefault(require("supertest"));
const ed25519_1 = require("@noble/curves/ed25519");
const bs58_1 = tslib_1.__importDefault(require("bs58"));
const convertToVercelTool_1 = require("@/lib/convertToVercelTool");
const schemaStructure_1 = require("@/lib/schemaStructure");
const client_auth_1 = require("@/client/client-auth");
const client_1 = require("@/client/client");
describe("DAIN Framework Integration", () => {
    const privateKey = ed25519_1.ed25519.utils.randomPrivateKey();
    const publicKey = ed25519_1.ed25519.getPublicKey(privateKey);
    const address = bs58_1.default.encode(publicKey);
    const clientPrivateKey = ed25519_1.ed25519.utils.randomPrivateKey();
    const agentAuth = new client_auth_1.DainClientAuth({
        privateKeyBase58: bs58_1.default.encode(clientPrivateKey),
        agentId: "agent-12",
        orgId: "org-12",
    });
    // Initialize the connection to the DAIN service
    const dainConnection = new client_1.DainServiceConnection(
    //agent URI
    "http://localhost:3003", agentAuth);
    const weatherTool = (0, nodeService_1.createTool)({
        id: "get-weather",
        name: "Get Weather",
        description: "Fetches weather for a city",
        input: zod_1.z.object({ city: zod_1.z.string() }),
        output: zod_1.z.object({ temperature: zod_1.z.number(), condition: zod_1.z.string() }),
        pricing: { pricePerUse: 0.01, currency: "USD" },
        handler: async ({ city }, agentInfo, context) => {
            // Send loading state
            if (context.updateUI) {
                await context.updateUI({ ui: { type: "loading", message: "Fetching weather..." } });
            }
            // Add a delay to ensure events are spaced out
            await new Promise(resolve => setTimeout(resolve, 1000));
            // Create a process
            const processId = await context.app.processes.createProcess(agentInfo, "one-time", "Weather Update", `Getting weather for ${city}`);
            // Notify about process creation
            if (context.addProcess) {
                await context.addProcess(processId);
            }
            // Add another delay
            await new Promise(resolve => setTimeout(resolve, 1000));
            if (context.updateUI) {
                await context.updateUI({ ui: { type: "progress", message: "Processing data..." } });
            }
            // Final delay before result
            await new Promise(resolve => setTimeout(resolve, 1000));
            return {
                text: `The weather in ${city} is Sunny with a temperature of 22°C.`,
                data: { temperature: 22, condition: "Sunny" },
                ui: null,
            };
        },
    });
    const extraDataTool = (0, nodeService_1.createTool)({
        id: "extra-data-tool",
        name: "Extra Data Tool",
        description: "Tool to test extra data",
        input: zod_1.z.object({ cool: zod_1.z.string() }),
        output: zod_1.z.any(),
        pricing: { pricePerUse: 0.01, currency: "USD" },
        handler: async (cool, agentInfo, { extraData }) => {
            console.log("cool", cool);
            console.log("agentInfo", agentInfo);
            console.log("extraData", extraData);
            return {
                text: `Extra data: ${JSON.stringify(extraData)}`,
                data: { extraData },
                ui: null,
            };
        },
    });
    // Add a tool with all optional parameters for testing empty param calls
    const optionalParamsTool = (0, nodeService_1.createTool)({
        id: "optional-params-tool",
        name: "Optional Parameters Tool",
        description: "Tool that can be called with empty parameters",
        input: zod_1.z.object({
            param1: zod_1.z.string().optional(),
            param2: zod_1.z.number().optional(),
            param3: zod_1.z.boolean().optional()
        }),
        output: zod_1.z.object({
            providedParams: zod_1.z.array(zod_1.z.string()),
            message: zod_1.z.string()
        }),
        handler: async (params, agentInfo, context) => {
            // Track which parameters were provided
            const providedParams = Object.keys(params || {});
            console.log("Received parameters:", providedParams.length ? providedParams : "none");
            return {
                text: `Called with ${providedParams.length} parameter(s): ${providedParams.join(', ')}`,
                data: {
                    providedParams,
                    message: providedParams.length > 0 ? "Parameters received" : "No parameters provided"
                },
                ui: null,
            };
        },
    });
    // Add a tool with no parameters for testing empty param calls
    const noParamsTool = (0, nodeService_1.createTool)({
        id: "no-params-tool",
        name: "No Parameters Tool",
        description: "Tool that requires no parameters",
        input: zod_1.z.object({}), // Empty schema - no parameters required
        output: zod_1.z.object({ message: zod_1.z.string() }),
        handler: async (_params, _agentInfo, _context) => {
            console.log("No-params tool called successfully");
            return {
                text: "No parameters tool executed successfully",
                data: { message: "Success - no parameters needed" },
                ui: null,
            };
        },
    });
    // Add a new tool with confirmation for testing
    const confirmationTool = (0, nodeService_1.createTool)({
        id: "confirmation-test-tool",
        name: "Confirmation Test Tool",
        description: "Tool that requires confirmation",
        input: zod_1.z.object({ action: zod_1.z.string() }),
        output: zod_1.z.object({ result: zod_1.z.string() }),
        suggestConfirmation: true,
        suggestConfirmationUI: async (input) => ({
            success: input.action !== "dangerous",
            ui: {
                type: "confirmation",
                title: "Confirm Action",
                message: `Are you sure you want to perform: ${input.action}?`,
                fields: [
                    {
                        type: "text",
                        label: "Additional Notes",
                        placeholder: "Add any notes here..."
                    }
                ]
            }
        }),
        handler: async ({ action }) => ({
            text: `Performed action: ${action}`,
            data: { result: `completed-${action}` },
            ui: null,
        }),
    });
    const weatherService = (0, nodeService_1.createService)({
        id: "weather-service",
        name: "Weather Service",
        description: "Provides weather information",
        metadata: {
            capabilities: ["current-weather"],
            languages: ["en"],
        },
        recommendedPrompt: "Ask about the weather",
        recommendedTools: ["get-weather", "extra-data-tool"],
    });
    const weatherToolbox = (0, nodeService_1.createToolbox)({
        id: "weather-toolbox",
        name: "Weather Toolbox",
        description: "Collection of weather tools",
        tools: ["get-weather", "extra-data-tool"],
        metadata: {
            complexity: "Low",
            applicableFields: ["Meteorology", "Travel"],
        },
        recommendedPrompt: "Use these tools for weather-related tasks",
    });
    const weatherContext = (0, core_1.createContext)({
        id: "weather-context",
        name: "Weather Context",
        description: "Context for weather data",
        getContextData: async () => {
            return "Weather data";
        },
    });
    // Create a datasource for testing
    const weatherDatasource = (0, core_1.createDatasource)({
        id: "weather-datasource",
        name: "Weather Datasource",
        description: "Datasource for weather data",
        type: "json",
        input: zod_1.z.object({
            city: zod_1.z.string().describe("The city to get weather data for"),
            days: zod_1.z.number().optional().describe("Number of days for forecast")
        }),
        getDatasource: async (agentInfo, params) => {
            return {
                city: params.city,
                forecast: [
                    { day: 1, temperature: 22, condition: "Sunny" },
                    { day: 2, temperature: 24, condition: "Partly Cloudy" },
                    { day: 3, temperature: 20, condition: "Rainy" }
                ].slice(0, params.days || 3)
            };
        },
    });
    const weatherPinnable = (0, core_1.createPinnable)({
        id: "weather-pinnable",
        type: "widget",
        label: "Weather Widget",
        name: "Weather Info",
        description: "Displays current weather information",
        icon: "☀️",
        getWidget: async () => ({
            text: "Current weather: Sunny, 22°C",
            data: { temperature: 22, condition: "Sunny" },
            ui: { type: "text" },
        }),
    });
    // Create a dedicated error tool for testing
    const errorTool = (0, nodeService_1.createTool)({
        id: "integration-error-tool",
        name: "Integration Error Tool",
        description: "Tool that deliberately throws errors for testing",
        input: zod_1.z.object({
            errorType: zod_1.z.enum(["none", "synchronous", "async", "input"]),
            errorMessage: zod_1.z.string().optional()
        }),
        output: zod_1.z.object({ result: zod_1.z.string() }),
        handler: async ({ errorType, errorMessage = "Deliberate test error" }, agentInfo, context) => {
            // Send UI update first to test partial success
            if (context.updateUI) {
                await context.updateUI({ ui: { type: "loading", message: "Starting error test..." } });
                // Small delay to ensure UI update goes through
                await new Promise(resolve => setTimeout(resolve, 200));
            }
            // Handle different error types
            switch (errorType) {
                case "none":
                    return {
                        text: "No error occurred",
                        data: { result: "success" },
                        ui: null
                    };
                case "synchronous":
                    throw new Error(errorMessage);
                case "async":
                    await new Promise(resolve => setTimeout(resolve, 300));
                    throw new Error(errorMessage);
                case "input":
                    // This simulates validation errors
                    throw new Error(`Invalid input: ${errorMessage}`);
            }
        },
    });
    const dainService = (0, nodeService_1.defineDAINService)({
        metadata: {
            title: "Weather DAIN Service",
            description: "A DAIN service for weather information",
            version: "1.0.0",
            author: "Test Author",
            tags: ["weather", "dain"],
        },
        identity: {
            publicKey: bs58_1.default.encode(publicKey),
            agentId: "weather-agent",
            orgId: "weather-org",
            privateKey: bs58_1.default.encode(privateKey),
        },
        services: [weatherService],
        tools: [weatherTool, extraDataTool, confirmationTool, optionalParamsTool, noParamsTool, errorTool],
        toolboxes: [weatherToolbox],
        contexts: [weatherContext],
        pinnables: [weatherPinnable],
        datasources: [weatherDatasource],
    });
    let server;
    beforeAll(async () => {
        server = await dainService.startNode({ port: 3003 });
    });
    afterAll(async () => {
        // Use a more robust approach to shutting down with proper cleanup
        if (server) {
            // Set a timeout for shutdown to complete
            const timeout = setTimeout(() => {
                console.warn('Server shutdown timed out, process may still have open handles');
            }, 5000);
            try {
                await server.shutdown();
            }
            catch (err) {
                console.error('Error shutting down server:', err);
            }
            finally {
                clearTimeout(timeout);
                server = null;
                // Wait a moment to allow any lingering connections to close
                await new Promise(resolve => setTimeout(resolve, 500));
            }
        }
    });
    test("Service metadata is correct", () => {
        const metadata = dainService.getMetadata();
        expect(metadata.title).toBe("Weather DAIN Service");
        expect(metadata.tags).toContain("weather");
    });
    test("Service has correct tools and services", () => {
        expect(dainService.getTools()).toHaveLength(6);
        expect(dainService.getServices()).toHaveLength(1);
        expect(dainService.getToolboxes()).toHaveLength(1);
    });
    test("Can call weather tool with valid signature", async () => {
        const app = server.address();
        const port = app.port;
        const response = await dainConnection.makeRequest("POST", "/tools/get-weather", { city: "New York" });
        expect(response).toEqual({
            data: { temperature: 22, condition: "Sunny" },
            text: "The weather in New York is Sunny with a temperature of 22°C.",
            ui: null,
        });
    });
    test("Rejects call with invalid signature", async () => {
        const app = server.address();
        const port = app.port;
        const method = "POST";
        const path = "/tools/get-weather";
        const body = JSON.stringify({ city: "New York" });
        const headers = {
            "Content-Type": "application/json",
            "X-DAIN-Address": address,
        };
        const timestamp = new Date().toISOString();
        headers["X-DAIN-Timestamp"] = timestamp;
        const response = await (0, supertest_1.default)(`http://localhost:${port}`)
            .post("/tools/get-weather")
            .set("X-DAIN-Signature", "1231232113121")
            .set("X-DAIN-Address", address)
            .set("X-DAIN-Timestamp", timestamp)
            .send({ city: "New York" });
        expect(response.status).toBe(401);
    });
    describe("HTTP Output to Vercel AI Tool", () => {
        it("should convert a DAIN tool to HTTP output and then to Vercel AI tool format", () => {
            // Simulate a DAIN tool
            const dainTool = {
                id: "get-weather",
                name: "Get Weather",
                description: "Fetches weather for a city",
                pricing: { pricePerUse: 0.01, currency: "USD" },
                input: zod_1.z.object({
                    city: zod_1.z.string().describe("The name of the city"),
                    country: zod_1.z.string().optional().describe("The country of the city"),
                }),
                output: zod_1.z.object({
                    temperature: zod_1.z.number(),
                    condition: zod_1.z.string(),
                }),
                handler: async () => ({ temperature: 22, condition: "Sunny" }),
            };
            // Simulate the HTTP output
            const httpOutput = {
                id: dainTool.id,
                name: dainTool.name,
                description: dainTool.description,
                pricing: dainTool.pricing,
                inputSchema: (0, schemaStructure_1.getDetailedSchemaStructure)(dainTool.input),
                outputSchema: (0, schemaStructure_1.getDetailedSchemaStructure)(dainTool.output),
            };
            // Convert HTTP output to Vercel AI tool
            const vercelAITool = (0, convertToVercelTool_1.convertHttpToolToVercelAITool)(httpOutput);
            // Assertions
            expect(vercelAITool.name).toBe("get-weather");
            expect(vercelAITool.description).toBe("Fetches weather for a city");
            expect(vercelAITool.parameters).toBeInstanceOf(zod_1.z.ZodObject);
            const params = vercelAITool.parameters.safeParse({
                city: "New York",
                country: "USA",
            });
            expect(params.success).toBe(true);
            // Use Zod's built-in methods to inspect the schema
            const schemaShape = vercelAITool.parameters._def.shape();
            expect(schemaShape.city.description).toBe("The name of the city");
            expect(schemaShape.country.description).toBe("The country of the city");
            // Test that the optional field is correctly preserved
            const paramsWithoutCountry = vercelAITool.parameters.safeParse({
                city: "Tokyo",
            });
            expect(paramsWithoutCountry.success).toBe(true);
            // Additional check for the optional nature of the country field
            expect(schemaShape.country instanceof zod_1.z.ZodOptional).toBe(true);
        });
    });
    it("Can List Contexts", async () => {
        const app = server.address();
        const port = app.port;
        const response = await dainConnection.makeRequest("GET", "/contexts", {});
        expect(response).toEqual([
            {
                id: "weather-context",
                name: "Weather Context",
                description: "Context for weather data",
            },
        ]);
    });
    it("Can call weather context with valid signature", async () => {
        const app = server.address();
        const port = app.port;
        const response = await dainConnection.makeRequest("GET", "/contexts/weather-context", {});
        expect(response).toEqual({
            id: "weather-context",
            name: "Weather Context",
            description: "Context for weather data",
            data: "Weather data",
        });
    });
    it("Can get all tools as json schema", async () => {
        const app = server.address();
        const port = app.port;
        const response = await dainConnection.makeRequest("GET", "/getAllToolsAsJsonSchema", {});
        console.log("JSON SCHEMA", JSON.stringify(response, null, 2));
        // fs.writeFileSync("jsonSchema.json", JSON.stringify(response, null, 2));
        expect(response).toEqual({
            "tools": [
                {
                    "id": "get-weather",
                    "name": "Get Weather",
                    "description": "Fetches weather for a city",
                    "inputSchema": {
                        "type": "object",
                        "properties": {
                            "city": {
                                "type": "string"
                            }
                        },
                        "required": [
                            "city"
                        ],
                        "additionalProperties": false,
                        "$schema": "http://json-schema.org/draft-07/schema#"
                    },
                    "outputSchema": {
                        "type": "object",
                        "properties": {
                            "temperature": {
                                "type": "number"
                            },
                            "condition": {
                                "type": "string"
                            }
                        },
                        "required": [
                            "temperature",
                            "condition"
                        ],
                        "additionalProperties": false,
                        "$schema": "http://json-schema.org/draft-07/schema#"
                    }
                },
                {
                    "id": "extra-data-tool",
                    "name": "Extra Data Tool",
                    "description": "Tool to test extra data",
                    "inputSchema": {
                        "type": "object",
                        "properties": {
                            "cool": {
                                "type": "string"
                            }
                        },
                        "required": [
                            "cool"
                        ],
                        "additionalProperties": false,
                        "$schema": "http://json-schema.org/draft-07/schema#"
                    },
                    "outputSchema": {
                        "$schema": "http://json-schema.org/draft-07/schema#"
                    }
                },
                {
                    "id": "confirmation-test-tool",
                    "name": "Confirmation Test Tool",
                    "description": "Tool that requires confirmation",
                    "inputSchema": {
                        "type": "object",
                        "properties": {
                            "action": {
                                "type": "string"
                            }
                        },
                        "required": [
                            "action"
                        ],
                        "additionalProperties": false,
                        "$schema": "http://json-schema.org/draft-07/schema#"
                    },
                    "outputSchema": {
                        "type": "object",
                        "properties": {
                            "result": {
                                "type": "string"
                            }
                        },
                        "required": [
                            "result"
                        ],
                        "additionalProperties": false,
                        "$schema": "http://json-schema.org/draft-07/schema#"
                    },
                    "suggestConfirmation": true
                },
                {
                    "id": "optional-params-tool",
                    "name": "Optional Parameters Tool",
                    "description": "Tool that can be called with empty parameters",
                    "inputSchema": {
                        "type": "object",
                        "properties": {
                            "param1": {
                                "type": "string"
                            },
                            "param2": {
                                "type": "number"
                            },
                            "param3": {
                                "type": "boolean"
                            }
                        },
                        "additionalProperties": false,
                        "$schema": "http://json-schema.org/draft-07/schema#"
                    },
                    "outputSchema": {
                        "type": "object",
                        "properties": {
                            "providedParams": {
                                "type": "array",
                                "items": {
                                    "type": "string"
                                }
                            },
                            "message": {
                                "type": "string"
                            }
                        },
                        "required": [
                            "providedParams",
                            "message"
                        ],
                        "additionalProperties": false,
                        "$schema": "http://json-schema.org/draft-07/schema#"
                    }
                },
                {
                    "id": "no-params-tool",
                    "name": "No Parameters Tool",
                    "description": "Tool that requires no parameters",
                    "inputSchema": {
                        "type": "object",
                        "properties": {},
                        "additionalProperties": false,
                        "$schema": "http://json-schema.org/draft-07/schema#"
                    },
                    "outputSchema": {
                        "type": "object",
                        "properties": {
                            "message": {
                                "type": "string"
                            }
                        },
                        "required": [
                            "message"
                        ],
                        "additionalProperties": false,
                        "$schema": "http://json-schema.org/draft-07/schema#"
                    }
                },
                {
                    "id": "integration-error-tool",
                    "name": "Integration Error Tool",
                    "description": "Tool that deliberately throws errors for testing",
                    "inputSchema": {
                        "type": "object",
                        "properties": {
                            "errorType": {
                                "type": "string",
                                "enum": [
                                    "none",
                                    "synchronous",
                                    "async",
                                    "input"
                                ]
                            },
                            "errorMessage": {
                                "type": "string"
                            }
                        },
                        "required": [
                            "errorType"
                        ],
                        "additionalProperties": false,
                        "$schema": "http://json-schema.org/draft-07/schema#"
                    },
                    "outputSchema": {
                        "type": "object",
                        "properties": {
                            "result": {
                                "type": "string"
                            }
                        },
                        "required": [
                            "result"
                        ],
                        "additionalProperties": false,
                        "$schema": "http://json-schema.org/draft-07/schema#"
                    }
                }
            ],
            "reccomendedPrompts": [
                "Use these tools for weather-related tasks"
            ]
        });
    });
    describe("Pinnables", () => {
        it("Can list pinnables", async () => {
            const response = await dainConnection.getPinnables();
            expect(response).toHaveLength(1);
            expect(response[0]).toEqual({
                id: "weather-pinnable",
                type: "widget",
                label: "Weather Widget",
                name: "Weather Info",
                description: "Displays current weather information",
                icon: "☀️",
                size: "small",
            });
        });
        it("Can get a specific pinnable", async () => {
            const response = await dainConnection.getPinnable("weather-pinnable");
            expect(response).toEqual({
                id: "weather-pinnable",
                type: "widget",
                label: "Weather Widget",
                name: "Weather Info",
                description: "Displays current weather information",
                icon: "☀️",
                size: "small",
                widget: {
                    text: "Current weather: Sunny, 22°C",
                    data: { temperature: 22, condition: "Sunny" },
                    ui: { type: "text" },
                },
            });
        });
        // extra data tool
        it("Can call extra data tool", async () => {
            const response = await dainConnection.callTool("extra-data-tool", {
                cool: "cool",
                DAIN_EXTRA_DATA: {
                    testExtraData: "testExtraData",
                },
            });
            expect(response).toEqual({
                text: `Extra data: ${JSON.stringify({ testExtraData: "testExtraData", plugins: {} })}`,
                data: { extraData: { testExtraData: "testExtraData", plugins: {} } },
                ui: null,
            });
        });
        it("Can get all pinnables with their widgets", async () => {
            const response = await dainConnection.getAllPinnables();
            expect(response).toHaveLength(1);
            expect(response[0]).toEqual({
                id: "weather-pinnable",
                type: "widget",
                label: "Weather Widget",
                size: "small",
                name: "Weather Info",
                description: "Displays current weather information",
                icon: "☀️",
                widget: {
                    text: "Current weather: Sunny, 22°C",
                    data: { temperature: 22, condition: "Sunny" },
                    ui: { type: "text" },
                },
            });
        });
        it("Rejects request for non-existent pinnable", async () => {
            await expect(dainConnection.getPinnable("non-existent-pinnable")).rejects.toThrow();
        });
    });
    // Add new test suite for confirmation functionality
    describe("Tool Confirmation", () => {
        it("Tool metadata includes confirmation settings", async () => {
            const tool = await dainConnection.getTool("confirmation-test-tool");
            expect(tool.suggestConfirmation).toBe(true);
        });
        it("Can get confirmation UI for a tool", async () => {
            const confirmation = await dainConnection.getToolConfirmation("confirmation-test-tool", {
                action: "test-action"
            });
            expect(confirmation).toEqual({
                success: true,
                ui: {
                    type: "confirmation",
                    title: "Confirm Action",
                    message: "Are you sure you want to perform: test-action?",
                    fields: [
                        {
                            type: "text",
                            label: "Additional Notes",
                            placeholder: "Add any notes here..."
                        }
                    ]
                }
            });
        });
        it("Returns success: false for dangerous actions", async () => {
            const confirmation = await dainConnection.getToolConfirmation("confirmation-test-tool", {
                action: "dangerous"
            });
            expect(confirmation.success).toBe(false);
        });
        it("Returns default success response for tools without confirmation UI", async () => {
            const confirmation = await dainConnection.getToolConfirmation("get-weather", {
                city: "London"
            });
            expect(confirmation).toEqual({
                success: true
            });
        });
        it("Rejects confirmation request for non-existent tool", async () => {
            await expect(dainConnection.getToolConfirmation("non-existent-tool", {})).rejects.toThrow();
        });
    });
    it("Can stream UI updates from weather tool", async () => {
        const uiUpdates = [];
        const result = await dainConnection.callTool("get-weather", { city: "London" }, {
            onUIUpdate: (update) => {
                uiUpdates.push(update.ui);
            }
        });
        // Verify UI updates were received
        expect(uiUpdates).toHaveLength(2);
        expect(uiUpdates[0]).toEqual({ type: "loading", message: "Fetching weather..." });
        expect(uiUpdates[1]).toEqual({ type: "progress", message: "Processing data..." });
        // Verify final result
        expect(result).toEqual({
            text: "The weather in London is Sunny with a temperature of 22°C.",
            data: { temperature: 22, condition: "Sunny" },
            ui: null,
        });
    });
    it("Maintains backwards compatibility with non-streaming clients", async () => {
        // Create a legacy client by removing the onUIUpdate option
        const result = await dainConnection.callTool("get-weather", {
            city: "London"
        });
        // Verify we get the final result without any streaming
        expect(result).toEqual({
            text: "The weather in London is Sunny with a temperature of 22°C.",
            data: { temperature: 22, condition: "Sunny" },
            ui: null,
        });
    });
    it("Maintains backwards compatibility for callToolAndGetNewContext", async () => {
        const result = await dainConnection.callToolAndGetNewContext("get-weather", {
            city: "London"
        });
        expect(result.toolResult).toEqual({
            text: "The weather in London is Sunny with a temperature of 22°C.",
            data: { temperature: 22, condition: "Sunny" },
            ui: null,
        });
        // Verify we still get context data
        expect(result.context).toBeDefined();
        expect(Array.isArray(result.context)).toBe(true);
        expect(result.context[0]).toHaveProperty('id', 'weather-context');
    });
    it("Can stream UI updates from weather tool with callToolAndGetNewContext", async () => {
        const uiUpdates = [];
        const result = await dainConnection.callToolAndGetNewContext("get-weather", { city: "Paris" }, {
            onUIUpdate: (update) => {
                uiUpdates.push(update.ui);
            }
        });
        // Verify UI updates were received
        expect(uiUpdates).toHaveLength(2);
        expect(uiUpdates[0]).toEqual({ type: "loading", message: "Fetching weather..." });
        expect(uiUpdates[1]).toEqual({ type: "progress", message: "Processing data..." });
        // Verify final result includes both tool result and context
        expect(result.toolResult).toEqual({
            text: "The weather in Paris is Sunny with a temperature of 22°C.",
            data: { temperature: 22, condition: "Sunny" },
            ui: null,
        });
        // Verify context data
        expect(result.context).toBeDefined();
        expect(Array.isArray(result.context)).toBe(true);
        expect(result.context[0]).toHaveProperty('id', 'weather-context');
    });
    it("Can stream process updates from weather tool", async () => {
        const uiUpdates = [];
        const processes = [];
        const result = await dainConnection.callTool("get-weather", { city: "London" }, {
            onUIUpdate: (update) => {
                uiUpdates.push(update.ui);
            },
            onProcess: (processId) => {
                processes.push(processId);
            }
        });
        // Verify process updates were received
        expect(processes).toHaveLength(1);
        expect(processes[0]).toMatch(/^service_.*_.*$/); // Check process ID format
        // Verify UI updates still work
        expect(uiUpdates).toHaveLength(2);
        // ... rest of the assertions ...
    });
    // Keep this test but modify it to be more explicit about timing
    it("Sends SSE events immediately rather than buffering", async () => {
        const events = [];
        let lastTimestamp = Date.now();
        const result = await dainConnection.callTool("get-weather", { city: "London" }, {
            onUIUpdate: () => {
                const now = Date.now();
                const delay = now - lastTimestamp;
                events.push({ type: 'ui', timestamp: now, delay });
                lastTimestamp = now;
                console.log('UI Update received at:', now, 'delay:', delay); // Add logging
            },
            onProcess: () => {
                const now = Date.now();
                const delay = now - lastTimestamp;
                events.push({ type: 'process', timestamp: now, delay });
                lastTimestamp = now;
                console.log('Process Update received at:', now, 'delay:', delay); // Add logging
            }
        });
        const now = Date.now();
        events.push({ type: 'result', timestamp: now, delay: now - lastTimestamp });
        console.log('Final result received at:', now); // Add logging
        // Verify we got all expected events
        expect(events).toHaveLength(4);
        // Log the events to see what's happening
        console.log('Events with delays:', events);
        // Check each event came after the previous one with reasonable delay
        events.slice(1).forEach(event => {
            expect(event.delay).toBeGreaterThan(30); // Each event should be at least 30ms after the previous
        });
    });
    // Add tests for datasources
    describe("Datasources", () => {
        it("Can list datasources", async () => {
            const response = await dainConnection.getDatasources();
            expect(response).toHaveLength(1);
            expect(response[0]).toEqual({
                id: "weather-datasource",
                name: "Weather Datasource",
                description: "Datasource for weather data",
                type: "json",
                inputSchema: expect.any(Object),
            });
        });
        it("Can get data from a datasource", async () => {
            const response = await dainConnection.getDatasource("weather-datasource", {
                city: "London",
                days: 2
            });
            expect(response).toEqual({
                id: "weather-datasource",
                name: "Weather Datasource",
                description: "Datasource for weather data",
                type: "json",
                data: {
                    city: "London",
                    forecast: [
                        { day: 1, temperature: 22, condition: "Sunny" },
                        { day: 2, temperature: 24, condition: "Partly Cloudy" }
                    ]
                }
            });
        });
        it("Handles missing parameters correctly", async () => {
            await expect(dainConnection.getDatasource("weather-datasource", {})).rejects.toThrow();
        });
        it("Rejects request for non-existent datasource", async () => {
            await expect(dainConnection.getDatasource("non-existent-datasource", { city: "London" })).rejects.toThrow();
        });
    });
    // Add tests for empty parameter tool calls
    describe("Empty Parameter Tool Calls", () => {
        it("Can call a tool with empty parameters object", async () => {
            const response = await dainConnection.callTool("optional-params-tool", {});
            expect(response.data.providedParams).toEqual([]);
            expect(response.data.message).toBe("No parameters provided");
            expect(response.text).toBe("Called with 0 parameter(s): ");
        });
        it("Can call a tool with some optional parameters", async () => {
            const response = await dainConnection.callTool("optional-params-tool", {
                param1: "test",
                param3: true
            });
            expect(response.data.providedParams).toContain("param1");
            expect(response.data.providedParams).toContain("param3");
            expect(response.data.providedParams).not.toContain("param2");
            expect(response.data.providedParams.length).toBe(2);
        });
        it("Can call a tool that requires no parameters", async () => {
            const response = await dainConnection.callTool("no-params-tool", {});
            expect(response.data.message).toBe("Success - no parameters needed");
            expect(response.text).toBe("No parameters tool executed successfully");
        });
        it("Handles undefined parameters gracefully", async () => {
            // Call with undefined instead of an empty object
            const response = await dainConnection.callTool("optional-params-tool", undefined);
            expect(response.data.providedParams).toEqual([]);
            expect(response.data.message).toBe("No parameters provided");
        });
        it("Works with streaming for empty parameter calls", async () => {
            const events = [];
            const result = await dainConnection.callTool("no-params-tool", {}, {
                onUIUpdate: (update) => {
                    events.push({ type: 'ui', data: update });
                }
            });
            expect(result.data.message).toBe("Success - no parameters needed");
        });
    });
    // Add a new test suite for error handling
    describe("Error Handling", () => {
        it("Handles synchronous errors in non-streaming mode", async () => {
            const errorResult = await dainConnection.callTool("integration-error-tool", {
                errorType: "synchronous",
                errorMessage: "Test sync error"
            });
            // Verify the error format matches our expected structure
            expect(errorResult).toHaveProperty('error');
            expect(errorResult).toHaveProperty('text');
            expect(errorResult.error).toBe("Test sync error");
            expect(errorResult.text).toBe("Error: Test sync error");
            expect(errorResult.data).toBeNull();
            expect(errorResult.ui).toBeNull();
        });
        it("Handles asynchronous errors in non-streaming mode", async () => {
            const errorResult = await dainConnection.callTool("integration-error-tool", {
                errorType: "async",
                errorMessage: "Test async error"
            });
            expect(errorResult).toHaveProperty('error');
            expect(errorResult.error).toBe("Test async error");
            expect(errorResult.data).toBeNull();
        });
        it("Formats errors correctly in context endpoint", async () => {
            const errorResult = await dainConnection.callToolAndGetNewContext("integration-error-tool", {
                errorType: "synchronous",
                errorMessage: "Test context error"
            });
            // Verify the context endpoint error format
            expect(errorResult).toHaveProperty('toolResult');
            expect(errorResult).toHaveProperty('context');
            expect(errorResult.toolResult).toHaveProperty('error');
            expect(errorResult.toolResult.error).toBe("Test context error");
            expect(errorResult.toolResult.text).toBe("Error: Test context error");
            expect(errorResult.toolResult.data).toBeNull();
            expect(errorResult.toolResult.ui).toBeNull();
            expect(Array.isArray(errorResult.context)).toBe(true);
            expect(errorResult.context.length).toBe(0);
        });
        it("Handles errors in streaming mode and sends error events", async () => {
            const events = [];
            const errorResult = await dainConnection.callTool("integration-error-tool", {
                errorType: "async",
                errorMessage: "Test streaming error"
            }, {
                onUIUpdate: (update) => {
                    events.push({ type: 'ui', data: update.ui });
                }
            });
            // Verify we received UI updates before the error
            expect(events.length).toBeGreaterThan(0);
            expect(events[0].type).toBe('ui');
            // Verify the error format in streaming mode
            expect(errorResult).toHaveProperty('error');
            expect(errorResult.error).toBe("Test streaming error");
            expect(errorResult.text).toBe("Error: Test streaming error");
            expect(errorResult.data).toBeNull();
            expect(errorResult.ui).toBeNull();
        });
        it("Handles streaming errors in context endpoint", async () => {
            const events = [];
            const errorResult = await dainConnection.callToolAndGetNewContext("integration-error-tool", {
                errorType: "async",
                errorMessage: "Test streaming context error"
            }, {
                onUIUpdate: (update) => {
                    events.push({ type: 'ui', data: update.ui });
                }
            });
            // Verify we received UI updates before the error
            expect(events.length).toBeGreaterThan(0);
            // Verify the context endpoint error format in streaming mode
            expect(errorResult).toHaveProperty('toolResult');
            expect(errorResult).toHaveProperty('context');
            expect(errorResult.toolResult).toHaveProperty('error');
            expect(errorResult.toolResult.error).toBe("Test streaming context error");
            expect(errorResult.toolResult.data).toBeNull();
            expect(Array.isArray(errorResult.context)).toBe(true);
        });
        it("Verifies successful execution still works after error handling improvements", async () => {
            const result = await dainConnection.callTool("integration-error-tool", {
                errorType: "none"
            });
            expect(result).toEqual({
                text: "No error occurred",
                data: { result: "success" },
                ui: null
            });
        });
    });
});
//# sourceMappingURL=integration.test.js.map