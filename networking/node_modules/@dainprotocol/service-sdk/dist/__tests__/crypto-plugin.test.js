"use strict";
// File: src/__tests__/crypto-plugin.test.ts
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const client_auth_1 = require("@/client/client-auth");
const client_1 = require("@/client/client");
const ed25519_1 = require("@noble/curves/ed25519");
const bs58_1 = tslib_1.__importDefault(require("bs58"));
const nodeService_1 = require("@/service/nodeService");
const core_1 = require("@/service/core");
const zod_1 = require("zod");
const crypto_plugin_1 = require("@/plugins/crypto-plugin");
const cuid2_1 = require("@paralleldrive/cuid2");
describe("DAIN Framework CryptoPlugin System", () => {
    // Generate test keys
    const servicePrivateKey = ed25519_1.ed25519.utils.randomPrivateKey();
    const servicePublicKey = ed25519_1.ed25519.getPublicKey(servicePrivateKey);
    const serviceAddress = bs58_1.default.encode(servicePublicKey);
    const clientPrivateKey = ed25519_1.ed25519.utils.randomPrivateKey();
    // Set up client authentication
    const agentAuth = new client_auth_1.DainClientAuth({
        privateKeyBase58: bs58_1.default.encode(clientPrivateKey),
        agentId: "agent-crypto-test",
        orgId: "org-crypto-test",
    });
    // Create a test wallet configuration
    const testWallets = [
        { chain: "sol", address: "Sol11111111111111111111111111111111111111111" },
        { chain: "eth", address: "0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266" },
        { chain: "arb", address: "0x70997970C51812dc3A010C7d01b50e0d17dc79C8" }
    ];
    // Create separate CryptoPlugin instances for client and service
    const clientCryptoPlugin = new crypto_plugin_1.CryptoPlugin(testWallets);
    const serviceCryptoPlugin = new crypto_plugin_1.CryptoPlugin(); // Service doesn't need wallet information
    // Initialize the connection to the DAIN service with the client crypto plugin
    const dainConnection = new client_1.DainServiceConnection("http://localhost:4485", agentAuth, {
        plugins: [clientCryptoPlugin]
    });
    // Create a mock Solana transaction (added id field)
    const mockSolanaTransaction = {
        encodedTx: "AQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA==",
        chain: "sol",
        signer: "Sol11111111111111111111111111111111111111111",
        metadata: {
            description: "Test SOL Transfer",
            amount: 0.01,
            recipient: "SolRecipient111111111111111111111111111111111"
        }
    };
    // Create a mock Ethereum transaction (added id field)
    const mockEthereumTransaction = {
        encodedTx: "0xf86c0a85046c7cfe0083016dea94d1310c1e0aa1b9d5dfe80aa9ee4a8b0a48d0f2a780a46057361d00000000000000000000000000000000000000000000000000000000000003e880820a95a0f5d4c5201602ddf5110f112a85fb0cf39a85e3a3174cd237b8383670cab7a3b5a048f2be5cc9f0a0b3f22e60f709c649d5a6a4ad3d70ce44ec80b96ffe7843508c",
        chain: "eth",
        signer: "0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266",
        metadata: {
            description: "Test ETH Transfer",
            amount: 0.1,
            recipient: "0x70997970C51812dc3A010C7d01b50e0d17dc79C8",
            gasLimit: 21000
        }
    };
    // Create a test tool that uses wallet information and creates unsigned transactions
    const cryptoTransferTool = (0, core_1.createTool)({
        id: "crypto-transfer",
        name: "Cryptocurrency Transfer Tool",
        description: "Creates unsigned transactions for cryptocurrency transfers",
        input: zod_1.z.object({
            amount: zod_1.z.number().positive(),
            chain: zod_1.z.enum(["sol", "eth", "arb"]),
            recipientAddress: zod_1.z.string()
        }),
        output: zod_1.z.object({
            success: zod_1.z.boolean(),
            message: zod_1.z.string(),
            signatureRequests: zod_1.z.array(zod_1.z.object({
                txs: zod_1.z.array(zod_1.z.object({
                    id: zod_1.z.string(),
                    encodedTx: zod_1.z.string(),
                    chain: zod_1.z.enum(["sol", "eth", "arb"]),
                    signer: zod_1.z.string(),
                    metadata: zod_1.z.any().optional()
                }))
            })).optional()
        }),
        handler: async ({ amount, chain, recipientAddress }, agentInfo, context) => {
            // Use the SERVICE-SIDE plugin (serviceCryptoPlugin) helper to get the user's wallets
            const wallets = serviceCryptoPlugin.getUserWallets(context);
            console.log(`[SERVICE] Available user wallets:`, wallets);
            // Get the wallet for the specified chain
            const userWallet = serviceCryptoPlugin.getUserWalletForChain(context, chain);
            if (!userWallet) {
                return {
                    text: `No wallet found for ${chain} chain`,
                    data: {
                        success: false,
                        message: `No ${chain} wallet found for this user. Please connect a ${chain} wallet.`
                    },
                    ui: null
                };
            }
            console.log(`[SERVICE] Using ${chain} wallet: ${userWallet} for transfer of ${amount} to ${recipientAddress}`);
            // Create mock transactions based on the chain
            let mockTransaction;
            if (chain === "sol") {
                mockTransaction = {
                    ...mockSolanaTransaction,
                    signer: userWallet,
                    metadata: {
                        ...mockSolanaTransaction.metadata,
                        amount: amount,
                        recipient: recipientAddress
                    }
                };
            }
            else if (chain === "eth" || chain === "arb") {
                mockTransaction = {
                    ...mockEthereumTransaction,
                    chain: chain,
                    signer: userWallet,
                    metadata: {
                        ...mockEthereumTransaction.metadata,
                        amount: amount,
                        recipient: recipientAddress
                    }
                };
            }
            else {
                return {
                    text: `Unsupported chain: ${chain}`,
                    data: {
                        success: false,
                        message: `Chain ${chain} is not supported yet.`
                    },
                    ui: null
                };
            }
            // Create a transaction with a unique ID using the service plugin helper
            const transactionWithId = serviceCryptoPlugin.createTransaction(mockTransaction);
            // Log the transaction ID for debugging
            console.log(`[SERVICE] Created transaction with ID: ${transactionWithId.id}`);
            // Create a signature request using the SERVICE-SIDE plugin helper
            const signatureRequest = serviceCryptoPlugin.createTransactionRequest([transactionWithId]);
            return {
                text: `Created unsigned ${chain} transaction for ${amount} to ${recipientAddress}`,
                data: {
                    success: true,
                    message: `Created unsigned ${chain} transaction. Please sign to complete the transfer.`,
                    signatureRequests: [signatureRequest]
                },
                ui: null
            };
        },
    });
    // Initialize the DAIN service with the SERVICE crypto plugin instance
    const dainService = (0, nodeService_1.defineDAINService)({
        metadata: {
            title: "Crypto Plugin Test Service",
            description: "A DAIN service for testing the crypto plugin",
            version: "1.0.0",
            author: "Test Author",
            tags: ["crypto", "plugin", "test"],
        },
        identity: {
            publicKey: bs58_1.default.encode(servicePublicKey),
            agentId: "crypto-agent",
            orgId: "crypto-org",
            privateKey: bs58_1.default.encode(servicePrivateKey),
        },
        tools: [cryptoTransferTool],
        plugins: [serviceCryptoPlugin] // Using service-side plugin instance
    });
    let server;
    beforeAll(async () => {
        server = await dainService.startNode({ port: 4485 });
        await new Promise(resolve => setTimeout(resolve, 500)); // Give server time to start
    });
    afterAll(async () => {
        await server.shutdown();
    });
    it("should assign unique IDs to transactions", async () => {
        console.log("[CLIENT] Using client plugin with wallets:", clientCryptoPlugin.getWallets());
        console.log("[SERVICE] Using service plugin with wallets:", serviceCryptoPlugin.getWallets());
        // Call the tool WITHOUT providing wallet information in the params
        // The client plugin should automatically add wallet info
        const params = {
            amount: 0.05,
            chain: "sol",
            recipientAddress: "SolRecipient222222222222222222222222222222222"
            // No wallets provided - they should come from the client plugin
        };
        // Call the tool
        const result = await dainConnection.callTool("crypto-transfer", params);
        console.log("[CLIENT] Received response:", JSON.stringify(result, null, 2));
        // Verify the response
        expect(result.data.success).toBe(true);
        expect(result.data.message).toContain("Created unsigned sol transaction");
        // Use the CLIENT plugin helper to extract transaction requests
        const signatureRequests = clientCryptoPlugin.getRequestedCryptoSignatures(result);
        console.log("[CLIENT] Extracted signature requests:", JSON.stringify(signatureRequests, null, 2));
        expect(signatureRequests).toBeDefined();
        expect(signatureRequests.length).toBe(1);
        expect(signatureRequests[0].txs.length).toBe(1);
        const transaction = signatureRequests[0].txs[0];
        expect(transaction.chain).toBe("sol");
        expect(transaction.signer).toBe(testWallets[0].address);
        expect(transaction.encodedTx).toBeDefined();
        // Verify the transaction has an ID
        expect(transaction.id).toBeDefined();
        expect(typeof transaction.id).toBe("string");
        expect(transaction.id.length).toBeGreaterThan(10);
        // Save the transaction ID for later use
        const txId = transaction.id;
        console.log(`[CLIENT] Transaction ID: ${txId}`);
        // Test getTransactionById method
        const foundTx = clientCryptoPlugin.getTransactionById(result, txId);
        expect(foundTx).toBeDefined();
        expect(foundTx?.id).toBe(txId);
    });
    it("should handle Ethereum transactions with unique IDs", async () => {
        // Prepare the tool parameters without wallet information
        const params = {
            amount: 0.25,
            chain: "eth",
            recipientAddress: "0xRecipientEthereumAddress0123456789abcdef"
            // No wallets provided - they should come from the client plugin
        };
        // Call the tool
        const result = await dainConnection.callTool("crypto-transfer", params);
        // Verify the response
        expect(result.data.success).toBe(true);
        expect(result.data.message).toContain("Created unsigned eth transaction");
        // Get transaction requests using the CLIENT plugin
        const signatureRequests = clientCryptoPlugin.getRequestedCryptoSignatures(result);
        const transaction = signatureRequests[0].txs[0];
        expect(transaction.chain).toBe("eth");
        expect(transaction.signer).toBe(testWallets[1].address);
        expect(transaction.metadata?.amount).toBe(0.25);
        expect(transaction.metadata?.recipient).toBe("0xRecipientEthereumAddress0123456789abcdef");
        // Verify the transaction has an ID
        expect(transaction.id).toBeDefined();
        expect(typeof transaction.id).toBe("string");
        console.log(`[CLIENT] Ethereum transaction ID: ${transaction.id}`);
    });
    it("should show wallet information flow and transaction IDs", async () => {
        // Add a new custom wallet to the client plugin
        clientCryptoPlugin.addWallet({
            chain: "sol",
            address: "CustomSolAddress123456789"
        });
        // Call the tool with the updated client plugin
        const result = await dainConnection.callTool("crypto-transfer", {
            amount: 0.75,
            chain: "sol",
            recipientAddress: "NewRecipientAddress"
        });
        // Verify the result uses the updated wallet
        const signatureRequests = clientCryptoPlugin.getRequestedCryptoSignatures(result);
        const transaction = signatureRequests[0].txs[0];
        // The address should be the new custom one we just added
        expect(transaction.signer).toBe("CustomSolAddress123456789");
        expect(transaction.metadata?.amount).toBe(0.75);
        // Verify the transaction has an ID
        expect(transaction.id).toBeDefined();
        console.log(`[CLIENT] Updated wallet transaction ID: ${transaction.id}`);
    });
    it("should demonstrate creating and accessing transactions with IDs", async () => {
        // Create a transaction directly with the createTransaction method
        const txData = {
            encodedTx: "0xManuallyCreatedTx",
            chain: "eth",
            signer: "0xManualAddress",
            metadata: { test: true, purpose: "Demo" }
        };
        // Create a transaction with the client plugin
        const tx1 = clientCryptoPlugin.createTransaction(txData);
        // Create another transaction with the same data
        const tx2 = clientCryptoPlugin.createTransaction(txData);
        // Create a transaction with a predefined ID
        const customId = (0, cuid2_1.createId)();
        const tx3 = clientCryptoPlugin.createTransaction({
            ...txData,
            id: customId
        });
        // Verify each transaction has a unique ID
        expect(tx1.id).toBeDefined();
        expect(tx2.id).toBeDefined();
        expect(tx3.id).toBeDefined();
        // Transaction IDs should be unique
        expect(tx1.id).not.toBe(tx2.id);
        // Custom ID should be preserved
        expect(tx3.id).toBe(customId);
        console.log(`[TEST] Manual transaction IDs:`, {
            tx1Id: tx1.id,
            tx2Id: tx2.id,
            tx3Id: tx3.id
        });
        // Create a signature request with multiple transactions
        const signatureRequest = clientCryptoPlugin.createTransactionRequest([tx1, tx2, tx3]);
        // Verify the signature request contains all transactions
        expect(signatureRequest.txs.length).toBe(3);
        expect(signatureRequest.txs.map(tx => tx.id)).toContain(tx1.id);
        expect(signatureRequest.txs.map(tx => tx.id)).toContain(tx2.id);
        expect(signatureRequest.txs.map(tx => tx.id)).toContain(tx3.id);
    });
    it("should allow service plugin to process transactions with additional data", async () => {
        // Create a new test with a local function that adds metadata
        // We'll use a real function instead of adding to the plugin instance
        const addServiceMetadata = (tx) => {
            return {
                ...tx,
                metadata: {
                    ...tx.metadata,
                    timestamp: Date.now(),
                    serviceId: "test-service-id",
                    enhanced: true
                }
            };
        };
        // Create a simple tool handler that would use this function
        // This simulates what a service would do
        const processTransaction = async (chain, userWallet) => {
            // Create a basic transaction with ID
            const baseTx = {
                encodedTx: "0xBasicTransaction",
                chain: chain,
                signer: userWallet,
                metadata: { basic: true }
            };
            // Create transaction with ID using the helper
            const tx = serviceCryptoPlugin.createTransaction(baseTx);
            // Enhance it with service-side metadata
            const enhancedTx = addServiceMetadata(tx);
            // Create the signature request
            const request = {
                txs: [enhancedTx]
            };
            return {
                success: true,
                signatureRequests: [request]
            };
        };
        // Simulate processing with a simple test
        const testWallet = "0xTestWalletAddress";
        const result = await processTransaction("eth", testWallet);
        // Verify the metadata was added
        expect(result.signatureRequests[0].txs[0].metadata?.enhanced).toBe(true);
        expect(result.signatureRequests[0].txs[0].metadata?.serviceId).toBe("test-service-id");
        expect(result.signatureRequests[0].txs[0].metadata?.timestamp).toBeDefined();
        expect(result.signatureRequests[0].txs[0].metadata?.basic).toBe(true); // Original data preserved
        // Make sure the transaction info is correct
        expect(result.signatureRequests[0].txs[0].chain).toBe("eth");
        expect(result.signatureRequests[0].txs[0].signer).toBe(testWallet);
        // Verify the transaction has an ID
        expect(result.signatureRequests[0].txs[0].id).toBeDefined();
        console.log(`[TEST] Service processed transaction ID: ${result.signatureRequests[0].txs[0].id}`);
    });
});
//# sourceMappingURL=crypto-plugin.test.js.map