"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const client_auth_1 = require("@/client/client-auth");
const client_1 = require("@/client/client");
const ed25519_1 = require("@noble/curves/ed25519");
const bs58_1 = tslib_1.__importDefault(require("bs58"));
const nodeService_1 = require("@/service/nodeService");
const core_1 = require("@/service/core");
const zod_1 = require("zod");
describe("DAIN Framework Streaming", () => {
    const privateKey = ed25519_1.ed25519.utils.randomPrivateKey();
    const publicKey = ed25519_1.ed25519.getPublicKey(privateKey);
    const address = bs58_1.default.encode(publicKey);
    const clientPrivateKey = ed25519_1.ed25519.utils.randomPrivateKey();
    const agentAuth = new client_auth_1.DainClientAuth({
        privateKeyBase58: bs58_1.default.encode(clientPrivateKey),
        agentId: "agent-12",
        orgId: "org-12",
    });
    // Initialize the connection to the DAIN service
    const dainConnection = new client_1.DainServiceConnection("http://localhost:4483", agentAuth);
    // Create a test tool with streaming updates
    const streamingTool = (0, core_1.createTool)({
        id: "streaming-test",
        name: "Streaming Test Tool",
        description: "Tool to test streaming functionality",
        input: zod_1.z.object({ message: zod_1.z.string() }),
        output: zod_1.z.object({ result: zod_1.z.string() }),
        handler: async ({ message }, agentInfo, context) => {
            console.log("Starting tool handler execution");
            // Send initial loading state
            if (context.updateUI) {
                console.log("Sending initial UI update");
                await context.updateUI({ ui: { type: "loading", message: "Starting..." } });
                console.log("Initial UI update sent");
            }
            // Add a delay - this is crucial for the test
            console.log("Starting first delay");
            await new Promise(resolve => setTimeout(resolve, 1000));
            console.log("First delay completed");
            // Create a process
            console.log("Creating process");
            const processId = await context.app.processes.createProcess(agentInfo, "one-time", "Streaming Test", `Testing streaming with: ${message}`);
            console.log("Process created with ID:", processId);
            // Notify about process creation
            if (context.addProcess) {
                console.log("Sending process update");
                await context.addProcess(processId);
                console.log("Process update sent");
            }
            // Add another delay
            console.log("Starting second delay");
            await new Promise(resolve => setTimeout(resolve, 1000));
            console.log("Second delay completed");
            // Send progress update
            if (context.updateUI) {
                console.log("Sending progress UI update");
                await context.updateUI({ ui: { type: "progress", message: "Processing..." } });
                console.log("Progress UI update sent");
            }
            // Final delay before result
            console.log("Starting final delay");
            await new Promise(resolve => setTimeout(resolve, 1000));
            console.log("Final delay completed");
            console.log("Returning final result");
            return {
                text: `Streaming test completed: ${message}`,
                data: { result: `completed-${message}` },
                ui: null,
            };
        },
    });
    // Add a streaming tool that accepts optional parameters
    const optionalStreamingTool = (0, core_1.createTool)({
        id: "optional-streaming-test",
        name: "Optional Streaming Test Tool",
        description: "Tool to test streaming with optional parameters",
        input: zod_1.z.object({
            message: zod_1.z.string().optional(),
            delay: zod_1.z.number().optional()
        }),
        output: zod_1.z.object({ result: zod_1.z.string() }),
        handler: async (params, agentInfo, context) => {
            console.log("Starting optional streaming tool with params:", params);
            // Get parameters or use defaults
            const message = params?.message || "Default message";
            const delay = params?.delay || 500; // Default delay
            // Send initial loading state
            if (context.updateUI) {
                console.log("Sending initial UI update");
                await context.updateUI({ ui: { type: "loading", message: "Starting optional streaming..." } });
            }
            // Add a delay
            console.log(`Delaying for ${delay}ms`);
            await new Promise(resolve => setTimeout(resolve, delay));
            // Send progress update
            if (context.updateUI) {
                console.log("Sending progress UI update");
                await context.updateUI({ ui: { type: "progress", message: "Processing with optional params..." } });
            }
            // Final delay before result
            await new Promise(resolve => setTimeout(resolve, delay / 2));
            console.log("Returning final result");
            return {
                text: `Optional streaming completed: ${message}`,
                data: { result: `completed-${message}-with-delay-${delay}` },
                ui: null,
            };
        },
    });
    // Create an error-throwing tool for testing
    const errorTool = (0, core_1.createTool)({
        id: "error-tool",
        name: "Error Tool",
        description: "Tool that throws errors",
        input: zod_1.z.object({ shouldThrow: zod_1.z.boolean() }),
        output: zod_1.z.object({ result: zod_1.z.string() }),
        handler: async ({ shouldThrow }) => {
            if (shouldThrow) {
                throw new Error("Intentional test error");
            }
            return {
                text: "No error occurred",
                data: { result: "success" },
                ui: null
            };
        },
    });
    const dainService = (0, nodeService_1.defineDAINService)({
        metadata: {
            title: "Streaming Test Service",
            description: "A DAIN service for testing streaming",
            version: "1.0.0",
            author: "Test Author",
            tags: ["streaming", "test"],
        },
        identity: {
            publicKey: bs58_1.default.encode(publicKey),
            agentId: "streaming-agent",
            orgId: "streaming-org",
            privateKey: bs58_1.default.encode(privateKey),
        },
        tools: [streamingTool, optionalStreamingTool, errorTool],
    });
    let server;
    beforeAll(async () => {
        server = await dainService.startNode({ port: 4483 });
    });
    afterAll(async () => {
        // Use a more robust approach to shutting down with proper cleanup
        if (server) {
            // Set a timeout for shutdown to complete
            const timeout = setTimeout(() => {
                console.warn('Server shutdown timed out, process may still have open handles');
            }, 5000);
            try {
                await server.shutdown();
            }
            catch (err) {
                console.error('Error shutting down server:', err);
            }
            finally {
                clearTimeout(timeout);
                server = null;
                // Wait a moment to allow any lingering connections to close
                await new Promise(resolve => setTimeout(resolve, 500));
            }
        }
    });
    it("Sends SSE events immediately rather than buffering", async () => {
        const events = [];
        let lastTimestamp = Date.now();
        // Add a longer delay before starting to ensure clean timing
        await new Promise(resolve => setTimeout(resolve, 1000));
        console.log("=".repeat(80));
        console.log("STARTING STREAMING TEST", new Date().toISOString());
        console.log("=".repeat(80));
        const startTime = Date.now();
        lastTimestamp = startTime;
        console.log("Starting test at:", new Date(lastTimestamp).toISOString());
        const resultPromise = dainConnection.callTool("streaming-test", { message: "test message" }, {
            onUIUpdate: (update) => {
                const now = Date.now();
                const delay = now - lastTimestamp;
                const elapsedFromStart = now - startTime;
                console.log(`[${elapsedFromStart}ms] UI Update received:`, JSON.stringify(update.ui));
                console.log(`Delay since last event: ${delay}ms`);
                events.push({ type: 'ui', timestamp: now, delay, data: update.ui });
                lastTimestamp = now;
            },
            onProcess: (processId) => {
                const now = Date.now();
                const delay = now - lastTimestamp;
                const elapsedFromStart = now - startTime;
                console.log(`[${elapsedFromStart}ms] Process Update received:`, processId);
                console.log(`Delay since last event: ${delay}ms`);
                events.push({ type: 'process', timestamp: now, delay, data: processId });
                lastTimestamp = now;
            }
        });
        // Wait for result
        const result = await resultPromise;
        const now = Date.now();
        const finalDelay = now - lastTimestamp;
        const totalTime = now - startTime;
        console.log(`[${totalTime}ms] Final result received, delay: ${finalDelay}ms`);
        events.push({ type: 'result', timestamp: now, delay: finalDelay, data: result });
        // Log all events with timing info
        console.log("\nDETAILED EVENT TIMELINE:");
        console.log("=".repeat(80));
        events.forEach((event, i) => {
            const timeFromStart = event.timestamp - startTime;
            const eventDate = new Date(event.timestamp).toISOString();
            console.log(`Event ${i + 1}: ${event.type}`);
            console.log(`  Time: ${eventDate} (${timeFromStart}ms from start)`);
            console.log(`  Delay since previous: ${event.delay}ms`);
            if (event.data) {
                if (typeof event.data === 'object') {
                    console.log(`  Data: ${JSON.stringify(event.data)}`);
                }
                else {
                    console.log(`  Data: ${event.data}`);
                }
            }
            console.log("-".repeat(40));
        });
        // Verify we got all expected events
        expect(events).toHaveLength(4);
        // Check that events are received in the correct order
        expect(events[0].type).toBe('ui');
        expect(events[1].type).toBe('process');
        expect(events[2].type).toBe('ui');
        expect(events[3].type).toBe('result');
        // Adjust expectations for the timing
        // First UI update might take longer due to connection setup
        expect(events[0].timestamp - startTime).toBeLessThan(10000);
        // For the delays between events, we need to be more lenient
        // as network conditions can vary, but there should be SOME delay
        expect(events[1].delay).toBeGreaterThan(10);
        expect(events[2].delay).toBeGreaterThan(10);
        expect(events[3].delay).toBeGreaterThan(10);
        // Verify spacing between events - they should align roughly with
        // our 1000ms delays in the handler
        const timeBetweenFirstAndProcess = events[1].timestamp - events[0].timestamp;
        const timeBetweenProcessAndSecondUI = events[2].timestamp - events[1].timestamp;
        const timeBetweenSecondUIAndResult = events[3].timestamp - events[2].timestamp;
        console.log("\nTIMES BETWEEN EVENTS:");
        console.log(`First UI to Process: ${timeBetweenFirstAndProcess}ms`);
        console.log(`Process to Second UI: ${timeBetweenProcessAndSecondUI}ms`);
        console.log(`Second UI to Result: ${timeBetweenSecondUIAndResult}ms`);
        // These should each be at least 500ms given our 1000ms delays
        // but we allow for some variance in timing
        expect(timeBetweenFirstAndProcess).toBeGreaterThan(100);
        expect(timeBetweenProcessAndSecondUI).toBeGreaterThan(100);
        expect(timeBetweenSecondUIAndResult).toBeGreaterThan(100);
    });
    it("Maintains backwards compatibility with non-streaming clients", async () => {
        const result = await dainConnection.callTool("streaming-test", {
            message: "test message"
        });
        expect(result).toEqual({
            text: "Streaming test completed: test message",
            data: { result: "completed-test message" },
            ui: null,
        });
    });
    it("Can stream UI updates with callToolAndGetNewContext", async () => {
        const events = [];
        let lastTimestamp = Date.now();
        // Add a longer delay before starting to ensure clean timing
        await new Promise(resolve => setTimeout(resolve, 1000));
        console.log("=".repeat(80));
        console.log("STARTING CONTEXT STREAMING TEST", new Date().toISOString());
        console.log("=".repeat(80));
        const startTime = Date.now();
        lastTimestamp = startTime;
        console.log("Starting context test at:", new Date(lastTimestamp).toISOString());
        const resultPromise = dainConnection.callToolAndGetNewContext("streaming-test", { message: "test message" }, {
            onUIUpdate: (update) => {
                const now = Date.now();
                const delay = now - lastTimestamp;
                const elapsedFromStart = now - startTime;
                console.log(`[${elapsedFromStart}ms] Context UI Update received:`, JSON.stringify(update.ui));
                console.log(`Delay since last event: ${delay}ms`);
                events.push({ type: 'ui', timestamp: now, delay, data: update.ui });
                lastTimestamp = now;
            },
            onProcess: (processId) => {
                const now = Date.now();
                const delay = now - lastTimestamp;
                const elapsedFromStart = now - startTime;
                console.log(`[${elapsedFromStart}ms] Context Process Update received:`, processId);
                console.log(`Delay since last event: ${delay}ms`);
                events.push({ type: 'process', timestamp: now, delay, data: processId });
                lastTimestamp = now;
            }
        });
        // Wait for result
        const result = await resultPromise;
        const now = Date.now();
        const finalDelay = now - lastTimestamp;
        const totalTime = now - startTime;
        console.log(`[${totalTime}ms] Context final result received, delay: ${finalDelay}ms`);
        events.push({ type: 'result', timestamp: now, delay: finalDelay, data: result });
        // Log all events with timing info
        console.log("\nDETAILED CONTEXT EVENT TIMELINE:");
        console.log("=".repeat(80));
        events.forEach((event, i) => {
            const timeFromStart = event.timestamp - startTime;
            const eventDate = new Date(event.timestamp).toISOString();
            console.log(`Event ${i + 1}: ${event.type}`);
            console.log(`  Time: ${eventDate} (${timeFromStart}ms from start)`);
            console.log(`  Delay since previous: ${event.delay}ms`);
            if (event.data) {
                if (typeof event.data === 'object') {
                    console.log(`  Data: ${JSON.stringify(event.data)}`);
                }
                else {
                    console.log(`  Data: ${event.data}`);
                }
            }
            console.log("-".repeat(40));
        });
        // Verify we got at least the UI updates
        expect(events.length).toBeGreaterThan(1);
        // Check if we have UI updates
        const uiEvents = events.filter(e => e.type === 'ui');
        expect(uiEvents.length).toBeGreaterThan(0);
        // Check the first UI event
        if (uiEvents.length >= 1) {
            expect(uiEvents[0].data).toEqual({ type: "loading", message: "Starting..." });
        }
        // Check the second UI event if it exists
        if (uiEvents.length >= 2) {
            expect(uiEvents[1].data).toEqual({ type: "progress", message: "Processing..." });
        }
        // Verify final result
        const resultEvent = events.find(e => e.type === 'result');
        expect(resultEvent).toBeDefined();
        expect(resultEvent.data.toolResult).toEqual({
            text: "Streaming test completed: test message",
            data: { result: "completed-test message" },
            ui: null,
        });
        // If we have more than one event, check that there are delays between them
        if (events.length > 1) {
            for (let i = 1; i < events.length; i++) {
                expect(events[i].delay).toBeGreaterThan(10);
            }
            // Calculate time between events
            if (events.length >= 3) {
                console.log("\nTIMES BETWEEN CONTEXT EVENTS:");
                for (let i = 1; i < events.length; i++) {
                    const timeFromPrevious = events[i].timestamp - events[i - 1].timestamp;
                    console.log(`From ${events[i - 1].type} to ${events[i].type}: ${timeFromPrevious}ms`);
                }
            }
        }
    });
    // Add test for streaming with empty parameters
    it("Can stream updates with empty parameter calls", async () => {
        const events = [];
        let lastTimestamp = Date.now();
        // Add a short delay before starting
        await new Promise(resolve => setTimeout(resolve, 500));
        console.log("=".repeat(80));
        console.log("STARTING EMPTY PARAMS STREAMING TEST", new Date().toISOString());
        console.log("=".repeat(80));
        const startTime = Date.now();
        lastTimestamp = startTime;
        // Call with empty parameters
        const result = await dainConnection.callTool("optional-streaming-test", {}, // Empty parameters object
        {
            onUIUpdate: (update) => {
                const now = Date.now();
                const delay = now - lastTimestamp;
                const elapsedFromStart = now - startTime;
                console.log(`[${elapsedFromStart}ms] Empty params UI Update:`, JSON.stringify(update.ui));
                events.push({ type: 'ui', timestamp: now, data: update.ui });
                lastTimestamp = now;
            }
        });
        const now = Date.now();
        const totalTime = now - startTime;
        console.log(`[${totalTime}ms] Empty params final result received`);
        events.push({ type: 'result', timestamp: now, data: result });
        // Verify we got UI updates
        expect(events.length).toBeGreaterThan(1);
        expect(events[0].type).toBe('ui');
        // Check the result
        expect(result.text).toBe("Optional streaming completed: Default message");
        expect(result.data.result).toBe("completed-Default message-with-delay-500");
    });
    // Test with undefined parameters
    it("Handles undefined parameters in streaming calls", async () => {
        // Call with undefined parameters
        const result = await dainConnection.callTool("optional-streaming-test", undefined, // Undefined parameters
        {
            onUIUpdate: () => { }
        });
        // Check the result - should use defaults
        expect(result.text).toBe("Optional streaming completed: Default message");
        expect(result.data.result).toBe("completed-Default message-with-delay-500");
    });
    it("Compares streaming between callTool and callToolAndGetNewContext", async () => {
        const callToolEvents = [];
        const callContextEvents = [];
        console.log("=".repeat(80));
        console.log("STARTING COMPARISON TEST", new Date().toISOString());
        console.log("=".repeat(80));
        // First use callTool with streaming
        const toolResult = await dainConnection.callTool("streaming-test", { message: "comparison-test" }, {
            onUIUpdate: (update) => {
                console.log("callTool UI Update:", JSON.stringify(update.ui));
                callToolEvents.push({ type: 'ui', data: update.ui });
            },
            onProcess: (processId) => {
                console.log("callTool Process Update:", processId);
                callToolEvents.push({ type: 'process', data: processId });
            }
        });
        callToolEvents.push({ type: 'result', data: toolResult });
        // Then use callToolAndGetNewContext with streaming
        const contextResult = await dainConnection.callToolAndGetNewContext("streaming-test", { message: "comparison-test" }, {
            onUIUpdate: (update) => {
                console.log("callToolAndGetNewContext UI Update:", JSON.stringify(update.ui));
                callContextEvents.push({ type: 'ui', data: update.ui });
            },
            onProcess: (processId) => {
                console.log("callToolAndGetNewContext Process Update:", processId);
                callContextEvents.push({ type: 'process', data: processId });
            }
        });
        callContextEvents.push({ type: 'result', data: contextResult });
        // Log all events for comparison
        console.log("\nCALL TOOL EVENTS:");
        console.log("-".repeat(80));
        callToolEvents.forEach((event, i) => {
            console.log(`Event ${i + 1}: ${event.type}`);
            if (event.data && typeof event.data === 'object') {
                console.log(`  Data: ${JSON.stringify(event.data).substring(0, 200)}${JSON.stringify(event.data).length > 200 ? '...' : ''}`);
            }
            else {
                console.log(`  Data: ${event.data}`);
            }
        });
        console.log("\nCALL TOOL AND GET NEW CONTEXT EVENTS:");
        console.log("-".repeat(80));
        callContextEvents.forEach((event, i) => {
            console.log(`Event ${i + 1}: ${event.type}`);
            if (event.data && typeof event.data === 'object') {
                console.log(`  Data: ${JSON.stringify(event.data).substring(0, 200)}${JSON.stringify(event.data).length > 200 ? '...' : ''}`);
            }
            else {
                console.log(`  Data: ${event.data}`);
            }
        });
        // COMPARISONS
        // Verify both received the same number of UI and process updates
        expect(callToolEvents.filter(e => e.type === 'ui').length)
            .toEqual(callContextEvents.filter(e => e.type === 'ui').length);
        expect(callToolEvents.filter(e => e.type === 'process').length)
            .toEqual(callContextEvents.filter(e => e.type === 'process').length);
        // Verify UI updates were identical
        const toolUiEvents = callToolEvents.filter(e => e.type === 'ui');
        const contextUiEvents = callContextEvents.filter(e => e.type === 'ui');
        toolUiEvents.forEach((toolEvent, i) => {
            expect(toolEvent.data).toEqual(contextUiEvents[i].data);
        });
        // Verify process IDs follow the same format
        const toolProcessEvents = callToolEvents.filter(e => e.type === 'process');
        const contextProcessEvents = callContextEvents.filter(e => e.type === 'process');
        toolProcessEvents.forEach((toolEvent, i) => {
            expect(typeof toolEvent.data).toEqual(typeof contextProcessEvents[i].data);
            expect(toolEvent.data).toMatch(/^service_.*_.*$/);
        });
        // Verify final results have the expected structure
        const toolResultEvent = callToolEvents.find(e => e.type === 'result');
        const contextResultEvent = callContextEvents.find(e => e.type === 'result');
        // callTool returns the direct result
        expect(toolResultEvent.data).toEqual({
            text: "Streaming test completed: comparison-test",
            data: { result: "completed-comparison-test" },
            ui: null,
        });
        // callToolAndGetNewContext returns { toolResult, context }
        expect(contextResultEvent.data).toHaveProperty('toolResult');
        expect(contextResultEvent.data).toHaveProperty('context');
        expect(contextResultEvent.data.toolResult).toEqual({
            text: "Streaming test completed: comparison-test",
            data: { result: "completed-comparison-test" },
            ui: null,
        });
        expect(Array.isArray(contextResultEvent.data.context)).toBe(true);
    }, 30000);
    it("Tests error handling in streaming mode", async () => {
        // Test callTool with error - we'll simulate an error by using an invalid tool ID
        let callToolError = null;
        try {
            const events = [];
            await dainConnection.callTool("non-existent-tool", { message: "error-test" }, {
                onUIUpdate: (update) => {
                    events.push({ type: 'ui', data: update.ui });
                }
            });
        }
        catch (err) {
            callToolError = err;
        }
        expect(callToolError).not.toBeNull();
        // Test callToolAndGetNewContext with error - also using invalid tool ID
        let callContextError = null;
        try {
            const events = [];
            await dainConnection.callToolAndGetNewContext("non-existent-tool", { message: "error-test" }, {
                onUIUpdate: (update) => {
                    events.push({ type: 'ui', data: update.ui });
                }
            });
        }
        catch (err) {
            callContextError = err;
        }
        expect(callContextError).not.toBeNull();
        // Test success case to ensure the streaming still works
        const result = await dainConnection.callTool("streaming-test", { message: "success-test" });
        expect(result).toEqual({
            text: "Streaming test completed: success-test",
            data: { result: "completed-success-test" },
            ui: null,
        });
    }, 30000);
    // Add a test for the new error handling in tool handlers
    it("Handles and formats tool handler errors correctly", async () => {
        // First test basic non-streaming error case
        console.log("\nTesting non-streaming error...");
        const basicErrorResult = await dainConnection.callTool("error-tool", { shouldThrow: true });
        // Verify the error format matches what we expect
        expect(basicErrorResult).toHaveProperty('error');
        expect(basicErrorResult).toHaveProperty('text');
        expect(basicErrorResult.error).toBe("Intentional test error");
        expect(basicErrorResult.text).toBe("Error: Intentional test error");
        expect(basicErrorResult.data).toBeNull();
        expect(basicErrorResult.ui).toBeNull();
        // Test context endpoint error format
        console.log("\nTesting context error...");
        const contextErrorResult = await dainConnection.callToolAndGetNewContext("error-tool", { shouldThrow: true });
        // Verify the context error format
        expect(contextErrorResult).toHaveProperty('toolResult');
        expect(contextErrorResult).toHaveProperty('context');
        expect(contextErrorResult.toolResult).toHaveProperty('error');
        expect(contextErrorResult.toolResult.error).toBe("Intentional test error");
        expect(contextErrorResult.toolResult.text).toBe("Error: Intentional test error");
        expect(contextErrorResult.toolResult.data).toBeNull();
        expect(contextErrorResult.toolResult.ui).toBeNull();
        expect(Array.isArray(contextErrorResult.context)).toBe(true);
        expect(contextErrorResult.context.length).toBe(0);
        // Test streaming error format
        console.log("\nTesting streaming error...");
        let streamingErrorEvents = [];
        const streamingErrorResult = await dainConnection.callTool("error-tool", { shouldThrow: true }, {
            onUIUpdate: (update) => {
                streamingErrorEvents.push({ type: 'ui', data: update.ui });
            }
        });
        // Verify streaming error format is the same
        expect(streamingErrorResult).toHaveProperty('error');
        expect(streamingErrorResult.error).toBe("Intentional test error");
        expect(streamingErrorResult.text).toBe("Error: Intentional test error");
        expect(streamingErrorResult.data).toBeNull();
        expect(streamingErrorResult.ui).toBeNull();
        // Test streaming context error format
        console.log("\nTesting streaming context error...");
        let streamingContextErrorEvents = [];
        const streamingContextErrorResult = await dainConnection.callToolAndGetNewContext("error-tool", { shouldThrow: true }, {
            onUIUpdate: (update) => {
                streamingContextErrorEvents.push({ type: 'ui', data: update.ui });
            }
        });
        // Verify streaming context error format
        expect(streamingContextErrorResult).toHaveProperty('toolResult');
        expect(streamingContextErrorResult).toHaveProperty('context');
        expect(streamingContextErrorResult.toolResult).toHaveProperty('error');
        expect(streamingContextErrorResult.toolResult.error).toBe("Intentional test error");
        expect(streamingContextErrorResult.toolResult.text).toBe("Error: Intentional test error");
        expect(streamingContextErrorResult.toolResult.data).toBeNull();
        expect(streamingContextErrorResult.toolResult.ui).toBeNull();
        expect(Array.isArray(streamingContextErrorResult.context)).toBe(true);
    }, 30000);
});
//# sourceMappingURL=streaming.test.js.map